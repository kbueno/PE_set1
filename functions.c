#include "functions.h"


// #1
//Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
//By starting with 1 and 2, the first 10 terms will be:
//1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
void number1 ()
{
	int result = 0, n = 1, p = 0, sum = 0;
	
	for (result = 0; result < 4000000; )
	{
		result = n + p;
		p = n;
		n = result;
		printf ("Fib: %d\t", result);

		if (result % 2 == 0)
		{
			sum += result;
			printf ("Sum of even: %d\n", sum);
		}

		putchar ('\n');
	}
}

// #2
//The prime factors of 13195 are 5, 7, 13 and 29.
//What is the largest prime factor of the number 600851475143 ?
void number2 ()
{
	int n = 13195, d = 2;

	printf ("Starting n: %d\n", n);

	while (n > 1)
	{
		if (d % 2 != 0 || d % 3 != 0 || d == 2 || d == 3)
		{
			if (n % d == 0)
			{
				n = n / d;
				printf ("%d -> ", d);
				d = 2;
			}
			else
				d++;
			
		}
		else
			d++;
	}
}

//A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 99.
//Find the largest palindrome made from the product of two 3-digit numbers.
void number3 ()
{
		int r = 0, num1 = 999, num2 = 999, status = 0, turn = 0;

	while (status == 0)
	{
		r = num1 * num2;
		//status = isPalin (r);

		if (status == 0 && turn == 1)
			num1--;
		else
			num2--;

		turn = (turn % 2) + 1;
	}
}

//2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
//What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20
void number4 ()
{
	int num = 0, status = 0, i;

	for (num = 20; status == 0; num++)
	{
		if (num % 11 == 0 && num % 13 == 0 && num % 14 == 0 && num % 14 == 0 && num % 16 == 0 &&
			num % 17 == 0 && num % 18 == 0 && num % 19 == 0 && num % 20 == 0)
		{
			status = 1;
		}
		else
			num++;
	}

	for (i = 2; i < 21; i++)
		printf ("%d mod %d = %d", num, i, num%i);
}

//The sum of the squares of the first ten natural numbers is,
//1^2 + 2^2 + ... + 10^2 = 385
//The square of the sum of the first ten natural numbers is,
//(1 + 2 + ... + 10)^2 = 55^2 = 3025
//Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
//Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
void number5 ()
{
	int sum = 0, i = 0, result = 0;

	for (i = 0; i < 100; i++)
	{
		sum += i;
	}
	result = pow((double)sum, 2);
	printf ("Square of Sums: %d\n", result);

	for (i = 0; i < 100; i++)
	{
		sum += pow((double)i, 2);
	}
	printf ("Sum of Squares: %d\n", sum);

	printf ("%d - %d = %d\n", result, sum, result - sum);
}

Node *makeNode (int data)
{
	Node *pMem = NULL;

	pMem = (Node *) malloc (sizeof (Node));

	if (pMem != NULL)
	{
		pMem->data = data;
		pMem->pNext = NULL;
	}

	return pMem;
}

void insertInOrder (Node **pList, int data)
{
	Node *pMem = NULL, *pPrev = NULL, *pCurr = NULL;

	pMem = makeNode (data);

	if (pMem != NULL)
	{
		//if list empty insert at front
		if (*pList == NULL)
		{
			*pList = pMem;
		}
		else //if list not empty
		{
			pCurr = *pList;
			while (pCurr != NULL && pMem->data > pCurr->data)
			{
				pPrev = pCurr;
				pCurr = pCurr->pNext;
			}

			//if at beginning of list, insert before
			if (pPrev == NULL)
			{
				pMem->pNext = *pList;
				*pList = pMem;
			}
			//if at end of list, insert at end
			else if (pCurr == NULL)
			{
				pPrev->pNext = pMem;
			}
			else //if in middle
			{
				pMem->pNext = pCurr;
				pPrev->pNext = pMem;
			}
		}
	}
}

Node *reverseOrder (Node *pList)
{
    Node *pCurr = NULL,*pTrans = NULL, *pPrev = NULL, *pFuture = NULL;
    
    if (pList == NULL)        //if empty list
        return pList;
    else                      //non empty list
    {
        pCurr = pList;
        if (pCurr->pNext == NULL)    //if only one node
            return pCurr;
        else
        {            
			pFuture = pCurr;
			while (pCurr != NULL)
            {                           
               	pFuture = pFuture->pNext;
				pCurr->pNext = pPrev;
                pPrev = pCurr;
				pCurr = pFuture;
            }
			return pPrev;
         }
        
    }
    
}

void printList (Node *pList)
{
	Node *pTemp = NULL;
	pTemp = pList;

	while (pTemp != NULL)
	{
		printf ("%d -> ", pTemp->data);
		pTemp = pTemp->pNext;
	}
}

//The following iterative sequence is defined for the set of positive integers:
//n = n/2 (n is even)
//n = 3n + 1 (n is odd)
//Using the rule above and starting with 13, we generate the following sequence:
//13  40  20  10  5  16  8  4  2  1
//It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), 
//it is thought that all starting numbers finish at 1.
//Which starting number, under one million, produces the longest chain?
//NOTE: Once the chain starts the terms are allowed to go above one million.
void number6 ()
{
	int n = 1000000, start = 0, count = 0, maxStart = 0, maxCount = 0;

	while(n > 0)
	{
		for (start = n; start > 1; count++)
		{			
			if (start % 2 == 0)
				start = start / 2;
			else
				start = (3 * start) + 1;
		}
		
		if (count > maxCount)
		{
			maxCount = count;
			maxStart = n;
		}
		count = 0;
		n--;
	}
		printf ("StartNum: %d, PrevCount: %d, MaxCount: %d, MaxStart: %d\n\n", n, count, maxCount, maxStart);
}

//The nth term of the sequence of triangle numbers is given by, tn = Â½n(n+1); so the first ten triangle numbers are:
//1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. 
//For example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we shall call the word a triangle word.
//Using words.txt (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?
void number42 ()
{
	int total = 0, i = 0, triCount = 0;
	double n = 0.0;
	const char word[10] = "SKY";
	char l = '\0';
	//FILE * infile = fopen ("word.txt", "r");

	//while (!feof(infile))
	//{
		//gets(word);
		for (i = 0; word[i] != '\0'; i++)
		{
			l = toupper(word[i]);
			printf ("Letter: %c\n", l);
			total += l - 'A' + 1;
		}
		printf ("Total: %d\n", total);

		//quadratic: 0 = n^2 + n - 2*total
		n = (-1 + sqrt(1 + 8 * total)) / 2;
		printf ("n: %lf\n", n);
		if (n == (int)n) //?
			triCount++;
	//}

	printf ("TriCount: %d\n", triCount);
	//fclose (infile);
}

//The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right,
//and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.
//Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
//NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.
void number8 ()
{


